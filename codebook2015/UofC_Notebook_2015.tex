\documentclass[letterpaper]{article}
\pagestyle{myheadings}
\markright{University of Calgary}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{courier}
\usepackage[margin=0.5in]{geometry}
\usepackage[hidelinks=true,pdftitle={University of Calgary C++ Codebook}]{hyperref}
\usepackage{listings}
\usepackage{multicol}
\usepackage{parskip}
\usepackage{tikz}
\usetikzlibrary{intersections}
\usepackage[compact]{titlesec}
\lstset{
	basicstyle=\ttfamily\footnotesize,
	language=c++,
	tabsize=4,
}
\setcounter{tocdepth}{2}
\setlength{\voffset}{0.5cm}
\setlength{\headsep}{0.5cm}
\newcommand{\rx}[1]{#1\hrule}
\begin{document}

\title{University of Calgary Team Reference Document 2015}
\maketitle
\thispagestyle{myheadings}
\markright{University of Calgary}

\begin{multicols*}{2}

\tableofcontents

\section{General Tips}
\begin{itemize}
\item For g++, \texttt{\#include <bits/stdc++.h>} includes all standard headers.
\item The constant $\pi$ is usually built-in as \texttt{M\_PI}.
\end{itemize}

\end{multicols*}

\section{Geometry}

\subsection{Basic 2D Geometry}

\begin{tabular}{@{}p{9cm}p{9cm}@{}}
\rx{Basic definitions}
\begin{lstlisting}
const double EP = 1e-9; // do not use for angles
typedef complex<double> PX;
const PX BAD(1e100,1e100);
\end{lstlisting}
\rx{Cross/dot product, same slope test}
\begin{lstlisting}
double cp(PX a, PX b) {return (conj(a)*b).imag();}
double dp(PX a, PX b) {return (conj(a)*b).real();}
bool ss(PX a, PX b) {return fabs(cp(a,b)) < EP;}
\end{lstlisting}
\rx{Orientation: $-1$=CW, 1=CCW, 0=colinear}
\begin{lstlisting}
// Can be used to check if a point is on a line (0)
int ccw(PX a, PX b, PX c) { 
	double r = cp(b-a, c-a);
	if (fabs(r) < EP) return 0;
	return r > 0 ? 1 : -1;
}
\end{lstlisting}
\rx{Check if $x$ is on line segment from $p_1$ to $p_2$}
\begin{lstlisting}
bool onSeg(PX p1, PX p2, PX x) { 
	return fabs(abs(p2-p1)-abs(x-p1)-abs(x-p2))<EP;
}
\end{lstlisting}
\rx{Point to line distance ($x$ to $p+\vec vt$)}
\begin{lstlisting}
double ptToLine(PX p, PX v, PX x) {
	// Closest point on line: p + v*dp(v, x-p)
	return fabs(cp(v, x-p) / abs(v));
}
\end{lstlisting}
&
\rx{Intersection point of two lines}
\begin{lstlisting}
PX lineIntersect(PX p1, PX v1, PX p2, PX v2) {
	// If colinear, pick random point (p1)
	if (ss(v1, v2)) return ss(v1, p2-p1) ? p1 : BAD; 
	return p1 + (cp(p2-p1,v2)/cp(v1,v2))*v1;
}
\end{lstlisting}
\rx{Intersection point of two line segments}
\begin{lstlisting}
PX segIntersect(PX p1, PX p2, PX q1, PX q2) {
	// Handle special cases for colinear
	if (onSeg(p1, p2, q1)) return q1;
	if (onSeg(p1, p2, q2)) return q2;
	if (onSeg(q1, q2, p1)) return p1;
	if (onSeg(q1, q2, p2)) return p2;
	PX ip = lineIntersect(p1, p2-p1, q1, q2-q1);
	return (onSeg(p1, p2, ip) && onSeg(q1, q2, ip))
		? ip : BAD;
}
\end{lstlisting}
\rx{Area of polygon (including concave)}
\begin{lstlisting}
double area(vector<PX> const& P) {
	double a = 0.0;
	for (int i = 0; i < P.size(); i++)
		a += cp(P[i], P[(i+1)%P.size()]);
	return 0.5 * fabs(a);
}
\end{lstlisting}
\rx{Check if point is within convex polygon}
\begin{lstlisting}
// P must be a convex polygon sorted CCW
bool ptInConvexPolygon(vector<PX> const& P, PX p) {
	for (int i = 0; i < P.size(); i++)
		// Use == -1 to include edges of polygon
		if (ccw(P[i], P[(i+1)%P.size()], p) != 1)
			return false;
	return true;
}
\end{lstlisting}
\end{tabular}

\subsection{Basic 3D Geometry}

TODO

\clearpage
\subsection{Convex Hull}

\begin{tabular}{@{}p{9cm}p{9cm}@{}}
Graham's scan. Complexity: $O\left(n\log n\right)$

\begin{lstlisting}
vector<PX> pts;
void convexHull() {
	if (pts.empty()) return;
	int fi = 0;
	for (int i = 1; i < pts.size(); i++)
		if (pts[i].imag() + EP < pts[fi].imag() || 
		   (fabs(pts[i].imag() - pts[fi].imag())<EP &&
		   pts[i].real() + EP < pts[fi].real())) fi = i;
	swap(pts[0], pts[fi]);
	sort(++pts.begin(), pts.end(), [](PX a, PX b) {
		PX v1 = a - pts[0], v2 = b - pts[0];
		double a1 = arg(v1), a2 = arg(v2);
		// Use smaller epsilon for angles
		if (fabs(a1 - a2) > 1e-14) return a1 < a2;
		return abs(v1) < abs(v2);
	});
	int M = 2;
	for (int i = 2; i < pts.size(); i++) {
		while (M > 1 && ccw(pts[M-2], pts[M-1], pts[i]) <= 0) M--;
		swap(pts[i], pts[M++]);
	}
	if (M < pts.size()) pts.resize(M);
}
\end{lstlisting}
&
Notes:
\begin{itemize}
\item All intermediate colinear points and duplicate points are discarded
\item If all points are colinear, the algorithm will output the two endpoints of the line
\item Works with any number of points including 0, 1, 2
\item Works with line segments colinear to the starting point
\end{itemize}
\end{tabular}

Example usage
\begin{lstlisting}
pts.clear();
pts.emplace_back(0.0, 0.0); // put all the points in
convexHull();
// pts now contains the convex hull in CCW order, starting from lowest y point
\end{lstlisting}

\clearpage

\section{Graphs}

\vspace*{-2em}
\begin{tabular}{@{}p{9cm}p{9cm}@{}}
\subsection{2-SAT}

Kosaraju's algorithm. Complexity: $O\left(V + E\right)$

\begin{lstlisting}
typedef vector<int> VI;
typedef vector<VI> VVI;

VVI adj, adjRev;
VI sccNum, sccStack, truthValues;

int VAR(int i) {return 2*i;}
int NOT(int i) {return i^1;}
int NVAR(int i) {return NOT(VAR(i));}
void addCond(int c1, int c2) {
	adj[NOT(c1)].push_back(c2);
	adjRev[c2].push_back(NOT(c1));
	adj[NOT(c2)].push_back(c1);
	adjRev[c1].push_back(NOT(c2));
}
void init2SAT(int numVars) {
	adj.clear(); adj.resize(2*numVars);
	adjRev.clear(); adjRev.resize(2*numVars);
}
void dfs(int i, int s, VVI& adj) {
	if (sccNum[i]) return;
	sccNum[i] = s;
	for (int j : adj[i]) dfs(j, s, adj);
	sccStack.push_back(i);
}
bool run2SAT() {
	sccStack.clear();
	sccNum.clear(); sccNum.resize(adj.size());
	for (int i = 0; i < adj.size(); i++) {
		dfs(i, 1, adj);
	}
	sccNum.clear(); sccNum.resize(adj.size());
	for (int s=1,i=sccStack.size()-1; i >= 0; i--) {
		int c = sccStack[i];
		if (sccNum[c]) continue;
		dfs(c, s++, adjRev);
	}
	truthValues.clear();
	truthValues.resize(adj.size()/2);
	for (int i = 0; i < adj.size(); i += 2) {
		if (sccNum[i] == sccNum[i+1]) return false;
		truthValues[i/2] = sccNum[i] > sccNum[i+1];
	}
	return true;
}
\end{lstlisting}
Example usage
\begin{lstlisting}
init2SAT(N); // variables from 0 to N-1
addCond(VAR(4), NVAR(0)); // v4 or not v0
if (run2SAT()) {
	// there is a solution
	// truth values are in truthValues[0 to N-1]
}
\end{lstlisting}

\subsection{Floyd-Warshall}

Complexity: $O\left(V^3\right)$

\begin{lstlisting}
let dist[V][V] be initialized to
	dist[v][v] = 0
	dist[u][v] = weight of edge else infinity
for k from 1 to V
	for i from 1 to V
		for j from 1 to V
			if dist[i][j] > dist[i][k] + dist[k][j]
				dist[i][j] = dist[i][k] + dist[k][j]
\end{lstlisting}
&
\subsection{Articulation Points and Bridges}
Graph does not need to be connected. Tested only on bidirectional (undirected) graphs. Complexity: $O\left(V + E\right)$

\begin{lstlisting}
typedef vector<int> VI;
typedef vector<VI> VVI;

VVI adj;
VI dfs_low, dfs_num;
int cnt;

void dfs(int i, int r, int p) { // (current, root, parent)
	if (dfs_num[i] != -1) return;
	dfs_low[i] = dfs_num[i] = cnt++;
	int ap = i != r; // number of disconnected
	                 // components if vertex is removed
	for (int j : adj[i])
	if (j != p) { // change cond if parallel edges
		if (dfs_num[j] == -1) {
			dfs(j, r, i);
			if (dfs_low[j] >= dfs_num[i]) ap++;
			if (dfs_low[j] > dfs_num[i]) {
				// (i,j) is a bridge
				// each pair will only occur once
			}
			dfs_low[i] = min(dfs_low[i], dfs_low[j]);
		} else {
			dfs_low[i] = min(dfs_low[i], dfs_num[j]);
		}
	}
	if (ap >= 2) {
		// i is an articulation point
		// each vertex will only occur once
	}
}
\end{lstlisting}

Example usage:
\begin{lstlisting}
// N is number of vertices
cnt = 0;
adj.assign(N, VI()); // fill adj
dfs_num.assign(N, -1);
dfs_low.resize(N); // initialization not necessary
for (int n = 0; n < N; n++) dfs(n, n, -1);
\end{lstlisting}

\subsection{Bellman-Ford}

Consider terminating the loop if no weight was modified in the loop. Complexity: $O(VE)$

\begin{lstlisting}
let weight[V] = all infinity except weight[source] = 0
let parent[V] = all null

loop V-1 times
	for each edge (u,v) with weight w
		if weight[u] + w < weight[v]
			weight[v] = weight[u] + w
			parent[v] = u

// detecting negative weight cycles
for each edge (u,v) with weight w
	if weight[u] + w < weight[v]
	then graph has negative weight cycle
\end{lstlisting}

\subsection{Eulerian Path/Cycle}

TODO

\end{tabular}

\clearpage

\vspace*{-3em}
\begin{tabular}{@{}p{7.5cm}p{10.5cm}@{}}
\subsection{Max Bipartite Matching}

Matches $M$ applicants to $N$ jobs.

Complexity: $O\left(V^3\right)$
\begin{lstlisting}
bool adj[M][N];
int matchR[N], seen[N];

bool bpm(int u) {
	for (int v = 0; v < N; v++) {
		if (adj[u][v] && !seen[v]) {
			seen[v] = true;
			if (matchR[v] < 0
			|| bpm(matchR[v])) {
				matchR[v] = u;
				return true;
			}
		}
	}
	return false;
}
\end{lstlisting}

Example usage:
\begin{lstlisting}
// adj must have all edges
memset(matchR, -1, sizeof matchR);
for (int u = 0; u < M; u++) {
	memset(seen, 0, sizeof seen);
	if (bpm(u)) then there is a matching
}
\end{lstlisting}

\subsection{Stable Marriage/Matching}

Only tested with equal numbers of men and women. Complexity: $O\left(MW\right)$

\begin{lstlisting}
typedef vector<int> VI;
vector<VI> mPref, wPref;
VI wPartner;
void stableMarriage() {
	int M = mPref.size();
	VI pr(M), fm(M);
	iota(begin(fm), end(fm), 0);
	wPartner.assign(wPref.size(), -1);
	while (!fm.empty()) {
		int m = fm.back();
		int w = mPref[m][pr[m]++];
		if (wPartner[w] == -1 || wPref[w][m]
		< wPref[w][wPartner[w]]) {
			fm.pop_back();
			if (wPartner[w] != -1)
				fm.push_back(wPartner[w]);
			wPartner[w] = m;
		}
	}
}
\end{lstlisting}

Example usage:
\begin{lstlisting}
mPref.clear(); wPref.clear();

// Man 0 ranks women 2, 0, 1 (best to worst)
mPref.push_back(VI{2,0,1});

// Woman 0 ranks men 1, 2, 0 (best to worst)
wPref.push_back(VI{2,0,1});

stableMarriage(); // matching is in wPartner
\end{lstlisting}

&
\subsection{Max Flow (with Min Cut)}

Edmonds-Karp algorithm.

Complexity: $O\left(\min\left(VE^2, fE\right)\right)$ where $f$ is the maximum flow

Note: The worst case performance is very rare and only happens with a specially crafted test case. Problem authors usually do not penalize you for using Edmonds-Karp over more efficient algorithms.

\begin{lstlisting}
typedef long long LL;
typedef pair<int,LL> PT;

vector<vector<int>> adj;
vector<int> parent;
unordered_map<int, unordered_map<int, LL>> cap; // or LL[][] if V is not too large

LL totalflow;
bool runMaxFlow(int source, int sink) {
	parent.assign(adj.size(), -1);
	parent[source] = -2; // use different value to recognize min cut
	queue<PT> bfs;
	bfs.emplace(source, 1LL<<60); // must be larger than max flow
	while (!bfs.empty()) {
		PT t = bfs.front();
		bfs.pop();
		for (int j : adj[t.first]) {
			if (cap[t.first][j] == 0 || parent[j] != -1) continue;
			parent[j] = t.first;
			LL f = min(t.second, cap[t.first][j]);
			if (j == sink) {
				while (j != source) {
					int p = parent[j];
					cap[p][j] -= f;
					cap[j][p] += f;
					j = p;
				}
				totalflow += f;
				return true;
			}
			bfs.emplace(j, f);
		}
	}
	return false;
}
void initMaxFlow(int nodes) {
	totalflow = 0;
	adj.clear(); adj.resize(nodes);
	cap.clear(); // or memset if cap is an array
}
void addEdge(int a, int b, LL w) {
	adj[a].push_back(b);
	adj[b].push_back(a); // even without bidirectional edges
	cap[a][b] = w;
	//cap[b][a] = w; // if you want bidirectional edges
}
\end{lstlisting}
Example usage
\begin{lstlisting}
initMaxFlow(desired number of nodes); // nodes from 0 to N-1
addEdge(0, 3, 123); // adds edge fron 0 to 3 with capacity 123
while (runMaxFlow(source, sink)) {}
// The max flow is now in totalflow
// The min cut: Nodes where parent[i] == -1 belong to the T
// component, otherwise S
\end{lstlisting}
\end{tabular}

\clearpage

\subsection{Min Cost Max Flow}

Edmonds-Karp with Bellman-Ford algorithm. Complexity: $O\left(\min\left(V^2E^2, fVE\right)\right)$ where $f$ is the maximum flow

Note: The worst case performance is very rare and only happens with a specially crafted test case. Problem authors usually do not penalize you for using Edmonds-Karp with Bellman-Ford over more efficient algorithms. The Bellman-Ford part of this code is designed to exit early whenever possible.

\begin{lstlisting}
const int NODES = 101 // maximum number of nodes
typedef long long LL;
typedef pair<int,int> PT;

vector<vector<int>> adj;
LL cap[NODES][NODES], cost[NODES][NODES], flow[NODES][NODES];

LL totalflow, totalcost;
bool runMCMF(int source, int sink) {
	vector<LL> mf(NODES), weight(NODES, 1LL<<60); // must be larger than longest path
	vector<int> parent(NODES, -1);
	weight[source] = 0;
	mf[source] = 1LL<<60; // value must be larger than max flow
	for (int i = 0, lm = 0; i < NODES-1 && lm == i; i++) {
		for (int u = 0; u < NODES; u++) {
			for (int v : adj[u]) {
				if (!cap[u][v] && !flow[v][u]) continue;
				LL w = (flow[v][u]) ? -cost[v][u] : cost[u][v];
				if (weight[u] + w < weight[v]) {
					weight[v] = weight[u] + w;
					parent[v] = u;
					mf[v] = min(mf[u], (flow[v][u]) ? flow[v][u] : cap[u][v]);
					lm = i+1;
				}
			}
		}
	}
	LL f = mf[sink];
	if (!f) return false;
	for (int j = sink; j != source;) {
		int p = parent[j];
		if (flow[j][p]) {
			cap[j][p] += f;
			flow[j][p] -= f;
		} else {
			cap[p][j] -= f;
			flow[p][j] += f;
		}
		totalcost += f * (weight[j] - weight[p]);
		j = p;
	}
	totalflow += f;
	return true;
}
void initMCMF() {
	totalflow = totalcost = 0;
	adj.clear(); adj.resize(NODES);
	memset(cap, 0, sizeof cap);
	memset(cost, 0, sizeof cost);
	memset(flow, 0, sizeof flow);
}
void addEdge(int a, int b, LL w, LL c) {
	adj[a].push_back(b);
	adj[b].push_back(a); // this line is necessary even without bidirectional edges
	cap[a][b] = w; // set cap[b][a] and cost[b][a] to the same to get bidirectional edges
	cost[a][b] = c;
}
\end{lstlisting}
Example usage
\begin{lstlisting}
initMCMF();
addEdge(0, 3, 123, 5); // adds edge fron 0 to 3 with capacity 123 and cost 5
while (runMCMF(source, sink)) {}
// The max flow is now in totalflow and total cost in totalcost
\end{lstlisting}

\clearpage

\section{Sequences and Strings}

\subsection {AVL Tree}

Creating your own BST can be useful in certain situations; e.g. to find the kth element in a set in $O\left(\log n\right)$.

\begin{tabular}{@{}p{9cm}p{9cm}@{}}
\begin{lstlisting}
struct node {
	node *l, *r;
	int nodes, height, val;
	node(int val)
	: l(0), r(0), nodes(1), height(1), val(val) {}
} *root;

int height(node *n) {return (n) ? n->height : 0;}
int nodes(node *n) {return (n) ? n->nodes : 0;}
int gb(node *n)
	{return (n) ? height(n->l) - height(n->r) : 0;}

void updHeight(node *n) {
	n->height = max(height(n->l), height(n->r)) + 1;
	n->nodes = nodes(n->l) + nodes(n->r) + 1;
}

void leftRotate(node **n) {
	node *nr = (**n).r;
	(**n).r = nr->l;
	nr->l = *n;
	*n = nr;
	updHeight((**n).l);
	updHeight(*n);
}
void rightRotate(node **n) {
	node *nr = (**n).l;
	(**n).l = nr->r;
	nr->r = *n;
	*n = nr;
	updHeight((**n).r);
	updHeight(*n);
}

void fix(node **n) {
	if (!*n) return;
	updHeight(*n);
	if (gb(*n) > 1) {
		if (gb((**n).l) < 0) leftRotate(&(**n).l);
		rightRotate(n);
	} else if (gb(*n) < -1) {
		if (gb((**n).r) > 0) rightRotate(&(**n).r);
		leftRotate(n);
	}
}

void insert(node **n, int val) {
	if (!*n) *n = new node(val);
	else if (val < (**n).val) insert(&(**n).l, val);
	else if (val > (**n).val) insert(&(**n).r, val);
	fix(n);
}

int predec(node **n) {
	int ret;
	if ((**n).r) ret = predec(&(**n).r);
	else {
		node *x = *n;
		*n = x->l;
		ret = x->val;
		delete x;
	}
	fix(n);
	return ret;
}
\end{lstlisting}
&
\begin{lstlisting}
void remove(node **n, int val) {
	if (!*n) return;
	if (val < (**n).val) remove(&(**n).l, val);
	else if (val > (**n).val) remove(&(**n).r, val);
	else if ((**n).l) (**n).val = predec(&(**n).l);
	else {
		node *x = *n;
		*n = x->r;
		delete x;
	}
	fix(n);
}
\end{lstlisting}
Example: in-order traversal
\begin{lstlisting}
void inorder(node *n) {
	if (!n) return;
	inorder(n->l);
	cout << n->val << endl;
	inorder(n->r);
}
\end{lstlisting}
Example: get kth element in set (zero-based)
\begin{lstlisting}
int kth(node *n, int k) {
	if (!n) return 2000000000;
	if (k < nodes(n->l)) return kth(n->l, k);
	else if (k > nodes(n->l))
		return kth(n->r, k - nodes(n->l) - 1);
	return n->val;
}
\end{lstlisting}
Example: count number of elements strictly less than $x$
\begin{lstlisting}
int count(node *n, int x) {
	if (!n) return 0;
	if (x <= n->val) return count(n->l, x);
	return 1 + nodes(n->l) + count(n->r, x);
}
\end{lstlisting}
\end{tabular}

\subsection{KMP}

Knuth-Morris-Pratt algorithm. Complexity: $O\left(m+n\right)$

This function returns a vector containing the zero-based index of the start of each match of K in S. It works with strings, vectors, and pretty much any array-indexed data structure that has a size method. Matches may overlap.

For GNU C++, \texttt{strstr()} uses KMP, but \texttt{string.find()} in C++ and \texttt{String.indexOf()} in Java do not.

\begin{lstlisting}
template<class T>
vector<int> KMP(T const& S, T const& K) {
	vector<int> b(K.size() + 1, -1);
	vector<int> matches;

	// Preprocess
	for (int i = 1; i <= K.size(); i++) {
		int pos = b[i - 1];
		while (pos != -1 && K[pos] != K[i - 1]) pos = b[pos];
		b[i] = pos + 1;
	}

	// Search
	int sp = 0, kp = 0;
	while (sp < S.size()) {
		while (kp != -1 && (kp == K.size() || K[kp] != S[sp])) kp = b[kp];
		kp++; sp++;
		if (kp == K.size()) matches.push_back(sp - K.size());
	}

	return matches;
}
\end{lstlisting}

\begin{tabular}{@{}p{9.5cm}p{8.5cm}@{}}
\subsection{Longest Common Subsequence}
Note that if characters are never repeated in at least one string, LCS can be reduced to LIS. Complexity: $O\left(nm\right)$

\begin{lstlisting}
template<class T>
int LCS(T const& A, T const& B) {
	int dp[][] = {}; // set size appropriately
	for (int a = 0; a < A.size(); a++) {
		for (int b = 0; b < B.size(); b++) {
			if (a) dp[a][b] = max(dp[a][b], dp[a-1][b]);
			if (b) dp[a][b] = max(dp[a][b], dp[a][b-1]);
			if (A[a] == B[b])
				dp[a][b] = max(dp[a][b], ((a && b) ? dp[a-1][b-1] : 0) + 1);
		}
	}
	return dp[A.size() - 1][B.size() - 1];
}
\end{lstlisting}
&
\subsection{Longest Increasing Subsequence}
Complexity: $O\left(n\log k\right)$ where $k$ is the length of the LIS

\begin{lstlisting}
vector<int> L; // L[x] = smallest end of length x LIS
for each x in sequence {
	auto it = lower_bound(L.begin(), L.end(), x);
	if (it == L.end()) L.push_back(x); else *it = x;
}
// Length of LIS is L.size()
\end{lstlisting}
\end{tabular}

\clearpage

\subsection{Fenwick Tree / Binary Indexed Tree}

This implements a $D$-dimensional Fenwick tree with indexes $\left[1,N-1\right]$. Complexity: $O\left(\log^DN\right)$ per operation

\begin{tabular}{@{}p{7cm}p{11cm}@{}}
\vspace*{-1em}
\begin{lstlisting}
template<int N, int D=1>
class FenwickTree {
	vector<int> tree;
	int isum(int ps) {return tree[ps];}
	template<class... T>
	int isum(int ps, int n, T... tail) {
		int a = 0;
		while (n) {
			a += isum(ps*N + n, tail...);
			n -= (n & -n);
		}
		return a;
	}
	void iupd(int u, int ps) {tree[ps] += u;}
	template<class... T>
	void iupd(int u, int ps, int n, T... tail) {
		while (n < N) { // TODO: check cond
			iupd(u, ps*N + n, tail...);
			n += (n & -n);
		}
	}
public:
	FenwickTree() : tree(pow(N, D)) {}
	template<class... T, class = class enable_if<sizeof...(T)==D>::type>
	int sum(T... v) {return isum(0, v...);}
	template<class... T, class = class enable_if<sizeof...(T)==D>::type>
	void upd(int u, T... v) {iupd(u, 0, v...);}
};
\end{lstlisting}
&
Example usage

\begin{lstlisting}
FenwickTree<130> t; // creates 1D fenwick tree with indexes [1,129]
t.upd(5, 7); // adds 5 to index 7
t.sum(14); // gets sum of all points [1, 14]

FenwickTree<130, 3> t; // creates 3D fenwick tree with indexes [1,129]
t.upd(5, 7, 8, 9); // adds 5 to the point (7, 8, 9)
t.sum(14, 15, 16); // gets sum of all points [(1, 1, 1), (14, 15, 16)]
\end{lstlisting}
\end{tabular}

Simple 1D tree (remember, first index is 1)

\begin{tabular}{@{}p{5cm}p{7cm}p{6cm}@{}}
\vspace*{-1em}
\begin{lstlisting}
typedef long long LL;
const int N = 100002;
LL f1[N], f2[N];

LL sum(LL *f, int n) {
	LL a = 0;
	while (n) {
		a += f[n];
		n -= (n & -n);
	}
	return a;
}
\end{lstlisting}
&
\vspace*{-1em}
\begin{lstlisting}
void upd(LL *f, int n, LL v) {
	while (n < N) {
		f[n] += v;
		n += (n & -n);
	}
}

// only required for range queries
// with range updates
LL rsum(int n) {
	return sum(f1, n) * n - sum(f2, n);
}
\end{lstlisting}
&
To get sum from $[p,q]$:
\begin{lstlisting}
rsum(q) - rsum(p-1)
\end{lstlisting}

To add $v$ to $[p,q]$:

\begin{lstlisting}
upd(f1, p, v);
upd(f1, q+1, -v);
upd(f2, p, v*(p-1));
upd(f2, q+1, -v*q);
\end{lstlisting}
\end{tabular}

\subsection{Sparse Table}

Solves static range min/max query with $O\left(n\log n\right)$ preprocessing and $O\left(1\right)$ per query. This code does range minimum query.

\begin{tabular}{@{}p{12cm}p{6cm}@{}}
\vspace*{-1em}
\begin{lstlisting}
int N, A[1000000], spt[1000000][19]; // spt[N][floor(log2(N))]

void sptBuild() {
	for (int n = 0; 1<<n <= N; n++)
		for (int i = 0; i+(1<<n) <= N; i++)
			spt[i][n] = (n) ? min(spt[i][n-1],
			                      spt[i+(1<<(n-1))][n-1]) : A[i];
}

int sptQuery(int i, int j) {
	int n = 31 - __builtin_clz(j-i+1); // floor(log2(j-i+1))
	return min(spt[i][n], spt[j+1-(1<<n)][n]);
}
\end{lstlisting}
&
Example usage
\begin{lstlisting}
N = 10; // size of array
A = {1, 5, -3, 7, -2, 1, 6, -8, 4, -2};
sptBuild();
sptQuery(0, 9); // returns -8
sptQuery(1, 1); // return 5
sptQuery(1, 4); // returns -3
sptQuery(5, 8); // returns -8
\end{lstlisting}
\end{tabular}

\clearpage

\subsection{Segment Tree}

The size of the segment tree should be 4 times the data size. Building is $O\left(n\right)$. Querying and updating is $O\left(\log n\right)$.

\begin{tabular}{@{}p{9.5cm}p{8.5cm}@{}}
\subsubsection{Example 1 (no range updates)}
This segment tree finds the maximum subsequence sum in an arbitrary range.

\begin{lstlisting}
int A[50000];

struct node {
	int bestPrefix, bestSuffix, bestSum, sum;
	void merge(node& ls, node& rs) {
		bestPrefix
			= max(ls.bestPrefix, ls.sum + rs.bestPrefix);
		bestSuffix
			= max(rs.bestSuffix, rs.sum + ls.bestSuffix);
		bestSum
			= max(ls.bestSuffix + rs.bestPrefix,
			  max(ls.bestSum, rs.bestSum));
		sum = ls.sum + rs.sum;
	}
} seg[200000];

void segBuild(int n, int l, int r) {
	if (l == r) {
		seg[n].bestPrefix = seg[n].bestSuffix
			= seg[n].bestSum = seg[n].sum = A[l];
		return;
	}
	int m = (l+r)/2;
	segBuild(2*n+1, l, m);
	segBuild(2*n+2, m+1, r);
	seg[n].merge(seg[2*n+1], seg[2*n+2]);
}

node segQuery(int n, int l, int r, int i, int j) {
	if (i <= l && r <= j) return seg[n];
	int m = (l+r)/2;
	if (m < i) return segQuery(2*n+2, m+1, r, i, j);
	if (m >= j) return segQuery(2*n+1, l, m, i, j);
	node ls = segQuery(2*n+1, l, m, i, j);
	node rs = segQuery(2*n+2, m+1, r, i, j);
	node a;
	a.merge(ls, rs);
	return a;
}

void segUpdate(int n, int l, int r, int i) {
	if (i < l || i > r) return;
	if (i == l && l == r) {
		seg[n].bestPrefix = seg[n].bestSuffix
			= seg[n].bestSum = seg[n].sum = A[l];
		return;
	}
	int m = (l+r)/2;
	segUpdate(2*n+1, l, m, i);
	segUpdate(2*n+2, m+1, r, i);
	seg[n].merge(seg[2*n+1], seg[2*n+2]);
}
\end{lstlisting}
&
\subsubsection{Example 2 (with range updates)}

This segment tree stores a series of booleans and allows swapping all booleans in any range.

\begin{lstlisting}
struct node {
	int sum;
	bool inv;
	void apply(int x) {
		sum = x - sum;
		inv = !inv;
	}
	void split(node& ls, node& rs, int l, int m, int r) {
		if (inv) {
			ls.apply(m-l+1);
			rs.apply(r-m);
			inv = false;
		}
	}
	void merge(node& ls, node& rs) {
		sum = ls.sum + rs.sum;
	}
} seg[200000];

node segQuery(int n, int l, int r, int i, int j) {
	if (i <= l && r <= j) return seg[n];
	int m = (l+r)/2;
	seg[n].split(seg[2*n+1],seg[2*n+2],l,m,r);
	if (m < i) return segQuery(2*n+2, m+1, r, i, j);
	if (m >= j) return segQuery(2*n+1, l, m, i, j);
	node ls = segQuery(2*n+1, l, m, i, j);
	node rs = segQuery(2*n+2, m+1, r, i, j);
	node a;
	a.merge(ls, rs);
	return a;
}

void segUpdate(int n, int l, int r, int i, int j) {
	if (i > r || j < l) return;
	if (i <= l && r <= j) {
		seg[n].apply(r-l+1);
		return;
	}
	int m = (l+r)/2;
	seg[n].split(seg[2*n+1],seg[2*n+2],l,m,r);
	segUpdate(2*n+1, l, m, i, j);
	segUpdate(2*n+2, m+1, r, i, j);
	seg[n].merge(seg[2*n+1], seg[2*n+2]);
}
\end{lstlisting}
\end{tabular}

Example usage:
\begin{lstlisting}
N = size of list;
segBuild(0, 0, N-1);
segQuery(0, 0, N-1, i, j); // queries range [i, j]
segUpdate(0, 0, N-1, i, j); // updates range [i, j] (you may need to add parameters)
\end{lstlisting}

\clearpage

\subsection{Suffix Array}

\vspace*{-2em}
\begin{tabular}{@{}p{9cm}p{9cm}@{}}

\subsubsection{Notes}
\begin{itemize}
\item Terminating character (\$) is not required (unlike CP book), but it is useful to compute the longest common substring of multiple strings
\item Use slow version if possible as it is shorter
\end{itemize}

\subsubsection{Initialization}

Complexity: $O\left(n\log^2 n\right)$

\begin{lstlisting}
typedef vector<int> VI;

VI sa, ra, lcp;
string s;

void saInit() {
	int l = s.size();
	sa.resize(l);
	iota(sa.begin(), sa.end(), 0);
	ra.assign(s.begin(), s.end());
	for (int k = 1; k < l; k *= 2) {
		// To use radix sort, replace sort() with:
		// csort(l, k); csort(l, 0);
		sort(sa.begin(), sa.end(), [&](int a, int b){
			if (ra[a] != ra[b]) return ra[a] < ra[b];
			int ak = a+k < l ? ra[a+k] : -1;
			int bk = b+k < l ? ra[b+k] : -1;
			return ak < bk;
		});
		VI ra2(l); int x = 0;
		for (int i = 1; i < l; i++) {
			if (ra[sa[i]] != ra[sa[i-1]] ||
				sa[i-1]+k >= l ||
				ra[sa[i]+k] != ra[sa[i-1]+k]) x++;
			ra2[sa[i]] = x;
		}
		ra = ra2;
	}
}
\end{lstlisting}

\subsubsection{Initialization (slow)}

Complexity: $O\left(n^2\log n\right)$

\begin{lstlisting}
void saInit() {
	int l = s.size();
	sa.resize(l);
	iota(sa.begin(), sa.end(), 0);
	sort(sa.begin(), sa.end(), [](int a, int b) {
		return s.compare(a, -1, s, b, -1) < 0;
	});
}
\end{lstlisting}

\subsubsection{Example suffix array}

{
\fontfamily{\ttdefault}\selectfont
\begin{tabular}{llll}
i & sa[i] & lcp[i] & Suffix\\ \hline
0 & 0 & 0 & abacabacx\\
1 & 4 & 4 & abacx\\
2 & 2 & 1 & acabacx\\
3 & 6 & 2 & acx\\
4 & 1 & 0 & bacabacx\\
5 & 5 & 3 & bacx\\
6 & 3 & 0 & cabacx\\
7 & 7 & 1 & cx\\
8 & 8 & 0 & x\\
\end{tabular}
}
&
\subsubsection{Longest Common Prefix array}

Complexity: $O\left(n\right)$

\begin{lstlisting}
void saLCP() {
	int l = s.size();
	lcp.resize(l);
	VI p(l), rsa(l);
	for (int i = 0; i < l; i++) {
		p[sa[i]] = (i) ? sa[i-1] : -1;
		rsa[sa[i]] = i;
	}
	int x = 0;
	for (int i = 0; i < l; i++) {
		// Note: The $ condition is optional and is
		// useful for finding longest common substring
		while (p[i] != -1 && p[i]+x < l &&
			s[i+x] == s[p[i]+x] && s[i+x] != '$') x++;
		lcp[rsa[i]] = x;
		if (x) x--;
	}
}
\end{lstlisting}

\subsubsection{String matching}

Returns a vector containing the zero-based index of the start of each match of \texttt{m} in \texttt{s}. Complexity: $O\left(m\log n\right)$

\begin{lstlisting}
VI saFind(string const& m) {
	auto r = equal_range(sa.begin(), sa.end(), -1,
	[&](int i, int j) {
		int a = 1;
		if (i == -1) {swap(i, j); a = -1;}
		return a*s.compare(i, m.size(), m) < 0;
	});
	VI occ(r.first, r.second);
	sort(occ.begin(), occ.end()); // optional
	return occ;
}
\end{lstlisting}
\subsubsection{Optional counting sort}
Improves \texttt{saInit()} performance to $O\left(n\log n\right)$

Usually not necessary, about 4x speed up on a 1M string
\begin{lstlisting}
void csort(int l, int k) {
	int m = max(300, l+1);
	VI c(m), sa2(l);
	for (int i = 0; i < l; i++) c[i+k<l ? ra[i+k]+1 : 0]++;
	for (int s = 0, i = 0; i < m; i++) {
		swap(c[i], s); s += c[i];
	}
	for (int i = 0; i < l; i++)
		sa2[c[sa[i]+k<l ? ra[sa[i]+k]+1 : 0]++] = sa[i];
	sa = sa2;
}
\end{lstlisting}
\subsubsection{Example usage}

\begin{lstlisting}
s = "abacabacx";
saInit(); // Now sa[] is filled
saLCP();  // Now lcp[] is filled
\end{lstlisting}

\end{tabular}

\clearpage

\section{Math and Other Algorithms}

\subsection{Exponentiation by Squaring}

Computes $x^n$. Complexity: $O\left(\log n\right)$ assuming multiplication and division are constant time.

\begin{lstlisting}
result = 1
while n is nonzero
	if n is odd
		result *= x
		n-= 1
	x *= x
	n /= 2
\end{lstlisting}

\subsection{Extended Euclidean and Modular Inverse}

\begin{tabular}{@{}p{9cm}p{9cm}@{}}
Complexity: $O\left(\log\left(\min\left(a,b\right)\right)\right)$

\begin{lstlisting}
int x, y, d;
void gcd(int a, int b) {
	if (b == 0) {x = 1; y = 0; d = a; return;}
	gcd(b, a % b);
	x -= y * (a / b);
	swap(x, y);
}
\end{lstlisting}
&
Finds $d=\gcd(a,b)$ and solves the equation $ax+by=d$. The equation $ax+by=c$ has a solution iff $c$ is a multiple of $d=\gcd(a,b)$. If $(x,y)$ is a solution, all other solutions have the form $(x + k\frac bd, y - k\frac ad), k\in\mathbb Z$.

To get modular inverse of $a$ modulo $m$, do \texttt{gcd(a, m)} and the inverse is $x$ (assuming inverse exists).
\end{tabular}

\subsection{Fast Fourier Transform}
\begin{tabular}{@{}p{10cm}p{8cm}@{}}
Cooley-Tukey algorithm. Complexity: $O\left(n\log n\right)$

\begin{lstlisting}
typedef complex<double> PX;
typedef valarray<PX> VPX;

void fft(VPX& p, double c=2.0) {
	size_t n = p.size();
	if (n == 1) return;
	VPX g = p[slice(0, n/2, 2)], h = p[slice(1, n/2, 2)];
	fft(g, c); fft(h, c);
	PX x0 = polar(1.0, c*M_PI/n), x = 1.0;
	for (size_t i = 0; i < n; i++) {
		p[i] = (i<n/2) ? g[i]+x*h[i] : g[i-n/2]+x*h[i-n/2];
		x *= x0;
	}
}

void ifft(VPX& p) {fft(p, -2.0); p /= p.size();}
\end{lstlisting}

Example: fast polynomial multiplication
\begin{lstlisting}
VPX polymul(VPX const& p1, VPX const& p2) {
	size_t pn = p1.size() + p2.size() - 1, n = pn;
	// round up n to nearest power of 2
	if (n & (n-1)) n = 1 << (32 - __builtin_clz(n));
	VPX p1e(n), p2e(n);
	copy(begin(p1), end(p1), begin(p1e));
	copy(begin(p2), end(p2), begin(p2e));
	fft(p1e); fft(p2e);
	p1e *= p2e;
	ifft(p1e);
	VPX p(pn);
	copy_n(begin(p1e), pn, begin(p));
	return p;
}
\end{lstlisting}
&
The discrete Fourier transform transforms a sequence of $N$ complex numbers $x_0,x_1,\cdots,x_{N-1}$ into an $N$-periodic sequence of complex numbers:

$$
X_k = \sum_{n=0}^{N-1} x_ne^{-i2\pi kn/N}
$$

Multiplying the individual terms of the DFT gives the convolution (polynomial multiplication):

$$
(f*g)[n] = \sum_{m=-\infty}^{\infty} f[m]g[n-m] = \sum_{m=-\infty}^{\infty} f[n-m]g[m]
$$

$$
x_N*y = \text{DFT}^{-1}\left[\text{DFT}\{x\}\cdot\text{DFT}\{y\}\right]
$$

\end{tabular}

\clearpage
\subsection{Sieve and Prime Factorization}

This sieve stores the smallest prime divisor (sp). Use 64-bit to avoid overflowing \texttt{i*i}. Prime factorization returns sorted pairs of prime factor and exponent.

\begin{tabular}{@{}p{6cm}p{6cm}p{6cm}@{}}

Sieve: $O\left(n\log\log n\right)$

\begin{lstlisting}
typedef vector<pair<int, int>> VP;
typedef long long LL;
const int MAX_P = 70000;

vector<int> primes;
int sp[MAX_P];

void sieve() {
	for (LL i = 2; i < MAX_P; i++) {
		if (sp[i]) continue;
		sp[i] = i;
		primes.push_back(i);
		for (LL j=i*i;j<MAX_P;j+=i)
			if(!sp[j]) sp[j] = i;
	}
}
\end{lstlisting}
&
Prime factorization: $O\left(\frac{\sqrt n}{\log n}\right)$

Works for $n<\mathrm{MAX\_P}^2$
\begin{lstlisting}
VP primeFactorize(int n) {
	VP f;
	for (int p : primes) {
		if (p*p > n) break;
		int a = 0;
		while (n % p == 0) {
			n /= p; a++;
		}
		if (a) f.emplace_back(p, a);
	}
	if (n != 1) f.emplace_back(n, 1);
	return f;
}
\end{lstlisting}
&
Prime factorization: $O\left(\log n\right)$

Works for $n<\mathrm{MAX\_P}$
\begin{lstlisting}
VP primeFactorize(int n) {
	VP f;
	while (n != 1) {
		int a = 0, p = sp[n];
		while (n % p == 0) {
			n /= p; a++;
		}
		f.emplace_back(p, a);
	}
	return f;
}
\end{lstlisting}
\end{tabular}

\subsection{Union-Find Disjoint Sets}

Complexity: $O\left(1\right)$ per operation. Note: $O\left(\log n\right)$ if one of union-by-rank or path compression is omitted

\begin{lstlisting}
vector<int> ds, dr;
int findSet(int i) {return ds[i] == i ? i : (ds[i] = findSet(ds[i]));}
void unionSet(int i, int j) {
	int x = findSet(i), y = findSet(j);
	if (dr[x] < dr[y]) ds[x] = y;
	else if (dr[x] > dr[y]) ds[y] = x;
	else {ds[x] = y; dr[y]++;}
}
bool sameSet(int i, int j) {return findSet(i) == findSet(j);}
\end{lstlisting}

Example initialization:

\begin{lstlisting}
dr.assign(N, 0);
ds.resize(N);
iota(begin(ds), end(ds), 0);
\end{lstlisting}

\clearpage
\subsection{Simplex}

\begin{tabular}{@{}p{9cm}p{9cm}@{}}
Complexity: Exponential in worst case, quite good on average
\begin{lstlisting}
const int MAXM = 100, MAXN = 100;
const double EPS = 1e-9, INF = 1.0/0.0;
double A[MAXM][MAXN], X[MAXN];
int basis[MAXM], out[MAXN];

void pivot(int m, int n, int a, int b) {
	int i, j;
	for (i = 0; i <= m; i++) if (i != a)
		for (j = 0; j <= n; j++) if (j != b)
			A[i][j] -= A[a][j] * A[i][b] / A[a][b];
	for (j = 0; j <= n; j++) if (j != b)
		A[a][j] /= A[a][b];
	for (i = 0; i <= m; i++) if (i != a)
		A[i][b] = -A[i][b]/A[a][b];

	A[a][b] = 1/A[a][b];

	i = basis[a];
	basis[a] = out[b];
	out[b] = i;
}

double simplex(int m, int n) {
	int i, j, ii, jj;

	for (j = 0; j <= n; j++) {
		A[0][j] *= -1;
		out[j] = j;
	}
	for (i = 0; i <= m; i++) basis[i] = -i;

	for (;;) {
		for (i = ii = 1; i <= m; i++)
			if (A[i][n] < A[ii][n] || (A[i][n]==A[ii][n] && basis[i]<basis[ii])) ii = i;
		if (A[ii][n] >= -EPS) break;
		for (j = jj = 0; j < n; j++)
			if (A[ii][j] < A[ii][jj]-EPS || (A[ii][j] < A[ii][jj]+EPS && out[i]<out[j])) jj=j;
		if (A[ii][jj] >= -EPS) return -INF;
		pivot(m,n,ii,jj);
	}
	for (;;) {
		for (j = jj = 0; j < n; j++)
			if (A[0][j] < A[0][jj] || (A[0][j] == A[0][jj] && out[j] < out[jj])) jj = j;
		if (A[0][jj] > -EPS) break;

		for (i=1,ii=0; i <= m; i++)
			if (A[i][jj] > EPS && (!ii || A[i][n]/A[i][jj] < A[ii][n]/A[ii][jj]-EPS ||
				(A[i][n]/A[i][jj] < A[ii][n]/A[ii][jj]+EPS && basis[i]<basis[ii]))) ii = i;
		if (A[ii][jj] <= EPS) return INF;
		pivot(m,n,ii,jj);
	}
	for (j = 0; j < n; j++) X[j] = 0;
	for (i = 1; i <= m; i++) if (basis[i] >= 0) X[basis[i]] = A[i][n];
	return A[0][n];
}
\end{lstlisting}
&
Notes:
\begin{itemize}
\item $m=$ number of inequalities
\item $n=$ number of variables
\item $A\left[m+1\right]\left[n+1\right]$ array of coefficients
\item Row 0 is the objective function
\item Rows 1 to $m$ are less-than inequalities
\item Columns 0 to $n-1$ are inequality coefficients
\item Column $n$ is the inequality constant

(0 for objective function)
\item $X[n]$ are result variables
\item Returns maximum value of objective function

($-\mathrm{INF}$ for infeasible, INF for unbounded)
\end{itemize}
\end{tabular}

\begin{tabular}{@{}p{5cm}p{9cm}@{}}
Example usage:
\begin{lstlisting}
memset(A, 0, sizeof A);
A[0] = {1,5,7};
A[1] = {2,4,5,12};
A[2] = {7,2,1,42};
double ans = simplex(2, 3);
double x1 = X[0]; //etc
\end{lstlisting}
&
Maximize $x_1+5x_2+7x_3=\mathrm{ans}$, where

$2x_1+4x_2+5x_3\leq12$

$7x_1+2x_2+x_3\leq42$
\end{tabular}

\clearpage

\section{Tricks for Bit Manipulation}

\subsection{GCC Builtins and Other Tricks}

For these builtins, you can append \texttt{l} or \texttt{ll} to the function names to get the \texttt{long} or \texttt{long long} version.

\begin{tabular}{lp{12cm}}
\begin{lstlisting}
int __builtin_ffs(int x)
\end{lstlisting} & Returns one plus the index of the least significant 1-bit of $x$. Returns 0 if $x=0$. \\
\begin{lstlisting}
int __builtin_clz(unsigned int x)
\end{lstlisting} & Returns the number of leading 0-bits in $x$, starting at the most significant bit position. If $x=0$, the result is undefined. \\
\begin{lstlisting}
int __builtin_ctz(unsigned int x)
\end{lstlisting} & Returns the number of trailing 0-bits in $x$, starting at the most significant bit position. If $x=0$, the result is undefined. \\
\begin{lstlisting}
int __builtin_clrsb(int x)
\end{lstlisting} & Returns the number of leading redundant sign bits in $x$, i.e. the number of bits following the most significant bit that are identical to it. There are no special cases for 0 or other values. \\
\begin{lstlisting}
int __builtin_popcount(unsigned int x)
\end{lstlisting} & Returns the number of 1-bits in $x$. (Slow on x86 without SSE4 flag) \\
\begin{lstlisting}
int __builtin_parity(unsigned int x)
\end{lstlisting} & Returns the parity of $x$, i.e. the number of 1-bits in $x$ modulo 2. \\
\begin{lstlisting}
uintN_t __builtin_bswapN(uintN_t x)
\end{lstlisting} & Returns $x$ with the order of the bytes reversed. $N=16,32,64$ \\
\begin{lstlisting}
(x & (x - 1)) == 0
\end{lstlisting} & Checks if $x$ is a power of 2 (only one bit set). Note: 0 is edge case. \\
\begin{lstlisting}
(x + y - 1) / y
\end{lstlisting} & Finds $\left\lceil\frac xy\right\rceil$ (positive integers only) \\
\end{tabular}

\subsection{Lexicographically Next Bit Permutation}
Suppose we have a pattern of N bits set to 1 in an integer and we want the next permutation of N 1 bits in a lexicographical sense. For example, if N is 3 and the bit pattern is 00010011, the next patterns would be 00010101, 00010110, 00011001, 00011010, 00011100, 00100011, and so forth. The following is a fast way to compute the next permutation.

\begin{lstlisting}
int bs = 0b11111; // whatever is first bit permutation
int t = bs | (bs - 1); // t gets v's least significant 0 bits set to 1
// Next set to 1 the most significant bit to change,
// set to 0 the least significant ones, and add the necessary 1 bits.
bs = (t + 1) | (((~t & -~t) - 1) >> (__builtin_ctz(bs) + 1));
\end{lstlisting}

\subsection{Loop Through All Subsets}
For example, if $\mathbf{bs} = 10110$, loop through $\mathbf{bt} = 10100, 10010, 10000, 00110, 00100, 00010$

\begin{lstlisting}
for (int bt = (bs-1) & bs; bt; bt = (bt-1) & bs) {
	int bu = bt ^ bs; // contains the opposite subset of bt (e.g. if bt = 10000, bu = 00110)
}
\end{lstlisting}

\subsection{Parsing and Printing \_\_int128}
GCC supports \texttt{(unsigned) \_\_int128} type on most platforms (notable exception is Windows). However, it does not currently support printing and parsing of those types.

\begin{lstlisting}
string printint128(__int128 a) { // prints as decimal
	if (!a) return "0";
	string s;
	while (a) {
		s = char(llabs(a % 10) + '0') + s;
		if (-10 < a && a < 0) s = '-' + s;
		a /= 10;
	}
	return s;
}

__int128 parseint128(string s) { // parses decimal number
	__int128 a = 0, sgn = 1;
	for (char c : s) {
		if (c == '-') sgn *= -1; else a = a * 10 + sgn * (c - '0');
	}
	return a;
}
\end{lstlisting}

\section{Math Formulas and Theorems}

\begin{tabular}{@{}p{4cm}p{14cm}@{}}
Catalan numbers&
\(C_{n+1} = \frac{2(2n+1)}{n+2}C_n\), \(C_0=1\)
\\
Chinese remainder theorem&Suppose $n_1\cdots n_k$ are positive integers that are pairwise coprime. Then, for any series of integers $a_1\cdots a_k$, there are an infinite number of solutions $x$ where

\[ \left\{
  \begin{array}{l l}
    x &= a_1\pmod {n_1}\\
	&\cdots\\
    x &= a_k\pmod {n_k}\\
  \end{array} \right.\]

All solutions $x$ are congruent modulo $N=n_1\cdots n_k$.

\\
Fermat's last theorem&No three positive integers $a$, $b$, and $c$ can satisfy the equation $a^n + b^n = c^n$ for any integer value of $n$ greater than 2.\\
Fermat's little theorem&For any prime $p$ and integer $a$, $a^p\equiv a\pmod p$. If $a$ is not divisible by $p$, then $a^{p-1}\equiv1\pmod p$ and $a^{p-2}$ is the modular inverse of $a$ modulo $p$.\\
Triangles&
$A=\frac12bh=\frac12ab\sin\gamma$

\begin{tikzpicture}
\draw (0,0) -- (5,0);
\draw (5,0) -- (1.5,2);
\draw (1.5,2) -- (0,0);
\draw (1.5,2) -- (1.5,0);
\draw[thin] (0.4,0) arc (0:45:0.5) 
  node[right] {$\gamma$};
\node[right] at (1.5,1) {$h$};
\node[right] at (0.2,1) {$a$};
\node[right] at (2,-0.2) {$b$};
\node[right] at (3.1,1.2) {$c$};
\end{tikzpicture}\\
Prime numbers

(all primes up to 547, and selected ones thereafter)&2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 179 181 191 193 197 199 211 223 227 229 233 239 241 251 257 263 269 271 277 281 283 293 307 311 313 317 331 337 347 349 353 359 367 373 379 383 389 397 401 409 419 421 431 433 439 443 449 457 461 463 467 479 487 491 499 503 509 521 523 541 547 577 607 641 661 701 739 769 811 839 877 911 947 983 1019 1049 1087 1109 1153 1193 1229 1277 1297 1321 1381 1429 1453 1487 1523 1559 1597 1619 1663 1699 1741 1783 1823 1871 1901 1949 1993 2017 2063 2089 2131 2161 2221 2267 2293 2339 2371 2393 2437 2473 2539 2579 2621 2663 2689 2713 2749 2791 2833 2861 2909 2957 3001 3041 3083 3137 3187 3221 3259 3313 3343 3373 3433 3467 3517 3541 3581 3617 3659 3697 3733 3779 3823 3863 3911 3931 4001 4021 4073 4111 4153 4211 4241 4271 4327 4363 4421 4457 4507 4547 4591 4639 4663 4721 4759 4799 4861 4909 4943 4973 5009 5051 5099 5147 5189 5233 5281 5333 5393 5419 5449 5501 5527 5573 5641 5659 5701 5743 5801 5839 5861 5897 5953 6029 6067 6101 6143 6199 6229 6271 6311 6343 6373 6427 6481 6551 6577 6637 6679 6709 6763 6803 6841 6883 6947 6971 7001 7043 7109 7159 7211 7243 7307 7349 7417 7477 7507 7541 7573 7603 7649 7691 7727 7789 7841 7879 13763 19213 59263 77339 117757 160997 287059 880247 2911561 4729819 9267707 9645917 11846141 23724047 39705719 48266341 473283821 654443183 793609931 997244057 8109530161 8556038527 8786201093 9349430521 70635580657 73695102059 79852211099 97982641721 219037536857 273750123551 356369453281 609592207993 2119196502847 3327101349167 4507255137769 7944521201081 39754306037983 54962747021723 60186673819997 98596209151961
\end{tabular}

\end{document}
